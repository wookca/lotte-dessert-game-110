<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />

  <!-- 모바일 화면 최적화 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <title>롯데리아 디저트 사전예약</title>

  <!-- ======================= Open Graph (카카오톡/메신저 미리보기) ======================= -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="롯데리아 디저트 사전예약" />
  <meta property="og:description" content="미니게임으로 사전예약 도전!" />
  <meta property="og:url" content="https://wookca.github.io/lotte-dessert-game-110/" />

  <!-- ✅ PC 카카오톡 호환성 높이기: JPG + secure_url + type + size -->
  <meta property="og:image" content="https://wookca.github.io/lotte-dessert-game-110/OG.jpg" />
  <meta property="og:image:secure_url" content="https://wookca.github.io/lotte-dessert-game-110/OG.jpg" />
  <meta property="og:image:type" content="image/jpeg" />

  <meta property="og:image:alt" content="롯데리아 디저트 사전예약 미니게임" />

  <!-- 일부 클라이언트 호환용(구형/보수적인 파서용) -->
  <link rel="image_src" href="https://wookca.github.io/lotte-dessert-game-110/OG.jpg" />

  <!-- (선택) 트위터도 같이 커버 -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="롯데리아 디저트 사전예약" />
  <meta name="twitter:description" content="미니게임으로 사전예약 도전!" />
  <meta name="twitter:image" content="https://wookca.github.io/lotte-dessert-game-110/OG.jpg" />

  <!-- Pretendard 웹폰트 로드 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" />

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QP0QSZJ9ZD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QP0QSZJ9ZD');
</script>

  <style>
    body {
      background: #111;
      color: #eee;
      font-family: "Pretendard", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      margin-top: 20px;
    }

    #gameCanvas {
      border: 2px solid #555;
      image-rendering: pixelated;
      background: #000;
    }

    .info {
      margin-top: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.4;
    }

    #bottom-controls {
      margin-top: 16px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding-bottom: 20px;
    }

    #bottom-controls button {
      box-sizing: border-box;
      border: 1px solid #444;
      background: #222;
      color: #f5f5f5;
      font-weight: 600;
      cursor: pointer;
      touch-action: manipulation;
    }

    #bottom-controls button:active {
      transform: scale(0.96);
      background: #444;
    }

    .direction-btn {
      width: 160px;
      height: 160px;
      border-radius: 50%;
      font-size: 96px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .restart-btn {
      width: 100%;
      max-width: 160px;
      border-radius: 999px;
      font-size: 16px;
      padding: 12px 0;
      min-height: 44px;
    }

    /* 모바일: 캔버스 가로 꽉 채우기 */
    @media (max-width: 900px) {
      #gameCanvas {
        width: 100vw;
        height: auto;
        max-width: 100vw;
      }
      body { margin-top: 0; }
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <div class="info">
    <div>조작: ↑ / ↓ 키로 이동</div>
    <div>
      <span style="color:#ffaf00;">수 많은 떼리앙을 피해 </span>
      <span style="color:#f00028;">롯데리아 디저트 사전예약하자</span>
    </div>
  </div>

  <div id="bottom-controls">
    <button id="btn-up" class="direction-btn" aria-label="위로 이동">&#9650;</button>
    <button id="btn-down" class="direction-btn" aria-label="아래로 이동">&#9660;</button>
    <button id="btn-restart" class="restart-btn">다시하기</button>
  </div>

<script>
// ======================= 공통 유틸 =======================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ======================= GA4 이벤트 헬퍼 =======================
function track(eventName, params = {}) {
  // 광고차단/로딩 타이밍 등으로 gtag가 없을 수도 있어서 안전하게
  if (typeof window.gtag === "function") {
    window.gtag("event", eventName, params);
  }
}


// 캔버스 포커스
canvas.tabIndex = 0; canvas.addEventListener("pointerdown", () => canvas.focus());


// ======================= BGM =======================
const BGM_SRC = "SRC/MON3_MIX_BGM.wav";   // ← 실제 파일 경로
const BGM_GAP_MS = 1000;         // 1초 텀

let bgmStarted = false;
const bgm = new Audio(BGM_SRC);
bgm.preload = "auto";
bgm.loop = true;

function startBgmOnce() {
  if (bgmStarted) return;
  bgmStarted = true;

  bgm.play().catch(() => {
    bgmStarted = false;
  });
}

function randRange(min, max) { return min + Math.random() * (max - min); }
function clamp(value, min, max) { return value < min ? min : (value > max ? max : value); }
function pointInRect(px, py, r) { return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h; }

// ======================= 외부 링크/텍스트 =======================
const YOUTUBE_URL = "https://www.youtube.com/watch?v=yfsR3TgRbTU";
const BU1_URL = "https://m.booking.naver.com/booking/6/bizes/1553263/items/7258189?startDate=2025-12-09";
const BU3_TEXT_TO_COPY = "https://wookca.github.io/lotte-dessert-game-110/";

// ======================= 그림자 스타일 =======================
const SHADOW_RGBA = "rgba(0, 14, 82, 0.4)";
const SHADOW_RGBA_STRONG = "rgba(0, 14, 82, 0.5)";

// ======================= END 버튼 캡쳐 숨김 플래그 =======================
let suppressEndButtonsForCapture = false;

// ======================= 토스트 =======================
let toastText = "";
let toastTimer = 0;

function showToast(text, duration = 1.4) {
  toastText = text;
  toastTimer = duration;
}
function updateToast(dt) {
  if (toastTimer > 0) {
    toastTimer -= dt;
    if (toastTimer < 0) toastTimer = 0;
  }
}
function drawToast() {
  if (!toastTimer || !toastText) return;

  const alpha = clamp(toastTimer / 1.4, 0, 1);

  ctx.save();
  ctx.globalAlpha = alpha;

  ctx.font = "14px 'Pretendard'";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const paddingX = 14;
  const textW = ctx.measureText(toastText).width;
  const boxW = clamp(textW + paddingX * 2, 140, 520);
  const boxH = 34;

  const x = canvas.width / 2;
  const y = canvas.height - 45;

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(x - boxW / 2, y - boxH / 2, boxW, boxH);

  ctx.fillStyle = "#fff";
  ctx.fillText(toastText, x, y);

  ctx.restore();
}

// ======================= 캡쳐 저장 (Bu_2) =======================
async function saveCanvasAsImage() {
  const filename = `lotte-dessert-${Date.now()}.png`;

  try {
    canvas.toDataURL("image/png");
  } catch (err) {
    console.error("[CAPTURE] toDataURL failed (tainted canvas?)", err);
    showToast("저장 실패: CORS/로컬실행 문제");
    return;
  }

  const prev = suppressEndButtonsForCapture;
  suppressEndButtonsForCapture = true;
  draw(); // 버튼 없이 한 번 그린 뒤 캡쳐

  if (!canvas.toBlob) {
    try {
      const dataUrl = canvas.toDataURL("image/png");
      window.open(dataUrl, "_blank");
      showToast("새 탭에서 이미지 열림");
    } finally {
      suppressEndButtonsForCapture = prev;
      draw();
    }
    return;
  }

  canvas.toBlob((blob) => {
    suppressEndButtonsForCapture = prev;
    draw();

    if (!blob) {
      console.error("[CAPTURE] toBlob returned null");
      showToast("저장 실패: 이미지 생성 불가");
      return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);

    requestAnimationFrame(() => {
      try {
        a.click();
        showToast("다운로드 폴더를 확인해줘!");
      } catch (err) {
        console.error("[CAPTURE] a.click failed", err);
        showToast("다운로드 트리거 실패");
      } finally {
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);
      }
    });
  }, "image/png");
}

// ======================= 링크 복사 (Bu_3) =======================
async function copyTextToClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    await navigator.clipboard.writeText(text);
    return true;
  }
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.setAttribute("readonly", "");
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  document.body.appendChild(ta);
  ta.select();

  let ok = false;
  try { ok = document.execCommand("copy"); } catch (_) { ok = false; }
  ta.remove();
  return ok;
}

// ======================= 전역 상수 =======================
// 진행/속도
const baseSpeed       = 280;
const MIN_SLOW_FACTOR = 0.05;
const goalDistance    = baseSpeed * 10;

// 깊이/레이어
const depthMinY = 140;
const depthMaxY = canvas.height - 30;

// 2.5D 스케일(오브젝트와 동일한 범위)
const DEPTH_MIN_SCALE = 0.85;
const DEPTH_MAX_SCALE = 1.15;

// 플레이어
const PLAYER_FRAME_COUNT  = 10;
const PLAYER_FRAME_WIDTH  = 100;
const PLAYER_FRAME_HEIGHT = 100;
const PLAYER_BASE_FPS     = 10;

// 오브젝트
const OBJ_FRAME_COUNT  = 10;
const OBJ_FRAME_WIDTH  = 100;
const OBJ_FRAME_HEIGHT = 100;
const OBJ_TYPES = ["PO", "BE", "CO", "FG", "FN", "JI", "CI"];
const OBJ_BASE_FPS = 8;

// ZI
const ZI_FRAME_COUNT  = 10;
const ZI_FRAME_WIDTH  = 200;
const ZI_FRAME_HEIGHT = 200;
const ZI_BASE_FPS     = 8;

// 판정 스케일
const PLAYER_HITBOX_SCALE = 0.6;
const OBJECT_HITBOX_SCALE = 0.5;

// ✅ (난이도 조정) 오브젝트 판정 Y축 절반 축소
const OBJECT_HITBOX_Y_FACTOR = 0.5;

// 스폰/타이밍
const OBSTACLE_SPAWN_INTERVAL_MIN = 0.2;
const OBSTACLE_SPAWN_INTERVAL_MAX = 0.4;
const ZI_SPAWN_INTERVAL_SECONDS   = 5;
const CI_SPAWN_INTERVAL_SECONDS   = 4;

// 말풍선
const SPEECH_ON_TIME    = 0.8;
const SPEECH_OFF_TIME   = 0.1;
const SPEECH_MAX_BLINKS = 4;

// 이동/흔들림 설정
const OBSTACLE_MOVE_CONFIG = {
  speedFactorMin: 0.7, speedFactorMax: 1.5,
  wiggleAmpMin: 2, wiggleAmpMax: 8,
  wiggleFreqMin: 1, wiggleFreqMax: 4,
  wanderMin: 0.7, wanderMax: 2.2
};
const CI_MOVE_CONFIG = {
  speedFactorMin: 2.0, speedFactorMax: 3.0,
  wiggleAmpMin: 1, wiggleAmpMax: 3,
  wiggleFreqMin: 2, wiggleFreqMax: 5,
  wanderMin: 0.5, wanderMax: 1.5
};
const ZI_MOVE_CONFIG = {
  speedFactorMin: 0.6, speedFactorMax: 1.0,
  wiggleAmpMin: 2, wiggleAmpMax: 6,
  wiggleFreqMin: 0.8, wiggleFreqMax: 2.3,
  wanderMin: 1.0, wanderMax: 3.0
};

// ======================= 이미지 로딩 =======================
// 메인 화면
const mainImage = new Image();
mainImage.src = "SRC/MAIN.png";
let mainLoaded = false;
mainImage.onload = () => mainLoaded = true;

// 배경
const bgImage = new Image();
bgImage.src = "SRC/BG.png";
let bgLoaded = false;
bgImage.onload = () => bgLoaded = true;

// 종료 화면
const endImage = new Image();
endImage.src = "SRC/END.png";
let endLoaded = false;
endImage.onload = () => endLoaded = true;

// END 버튼 + END 전용 이미지(sp2)
const endButtons = [
  { key: "bu1", img: new Image(), src: "SRC/Bu_1.png", w: 150, h: 42, loaded: false },
  { key: "bu2", img: new Image(), src: "SRC/Bu_2.png", w: 42,  h: 42, loaded: false },
  { key: "bu3", img: new Image(), src: "SRC/Bu_3.png", w: 42,  h: 42, loaded: false },
  { key: "bu4", img: new Image(), src: "SRC/Bu_4.png", w: 42,  h: 42, loaded: false }, // ✅ 콤마 누락 수정
  { key: "sp2", img: new Image(), src: "SRC/speech2.png", w: 100, h: 60, loaded: false } // ✅ 추가
];
for (const b of endButtons) {
  b.img.src = b.src;
  b.img.onload = () => (b.loaded = true);
}

// 말풍선
const speechImg = new Image();
speechImg.src = "SRC/speech.png";
let speechLoaded = false;
speechImg.onload = () => speechLoaded = true;

// 플레이어 스프라이트
const playerFrames = [];
let playerFramesLoaded = 0;
for (let i = 1; i <= PLAYER_FRAME_COUNT; i++) {
  const img = new Image();
  const num = String(i).padStart(5, "0");
  img.src = `SRC/CH/POTE/POTE_${num}.png`;
  img.onload = () => playerFramesLoaded++;
  playerFrames.push(img);
}

// 오브젝트 스프라이트
const objSpriteSets = {};
OBJ_TYPES.forEach(type => {
  const frames = [];
  const spriteSet = { frames, loaded: 0 };
  objSpriteSets[type] = spriteSet;

  for (let i = 1; i <= OBJ_FRAME_COUNT; i++) {
    const img = new Image();
    const num = String(i).padStart(5, "0");
    img.src = `SRC/CH/${type}/${type}_${num}.png`;
    img.onload = () => spriteSet.loaded++;
    frames.push(img);
  }
});

// ZI 스프라이트
const ziFrames = [];
let ziFramesLoaded = 0;
for (let i = 1; i <= ZI_FRAME_COUNT; i++) {
  const img = new Image();
  const num = String(i).padStart(5, "0");
  img.src = `SRC/CH/ZI/ZI_${num}.png`;
  img.onload = () => ziFramesLoaded++;
  ziFrames.push(img);
}

// ======================= 상태값 =======================
// 플레이어
const player = { x: 100, y: 200, w: 100, h: 100, baseSpeedY: 260, color: "#ffd966" };

const playerMinY = 110;
const playerMaxY = canvas.height - player.h;

// 애니메이션
let playerFrameIndex = 0, playerFrameTimer = 0;
let objFrameIndex = 0, objFrameTimer = 0;
let ziFrameIndex = 0, ziFrameTimer = 0;

// 게임 진행
let distance = 0;
let elapsedTime = 0;
let obstacles = [];
let specials = [];
let obstacleSpawnTimer = 0;

let nextZiSpawnTime = ZI_SPAWN_INTERVAL_SECONDS;
let nextCiSpawnTime = CI_SPAWN_INTERVAL_SECONDS;

let gameState = "ready";
let lastTime = 0;

// 말풍선 상태
let speechTimer = 0;
let speechVisible = false;
let speechBlinkCount = 0;
let speechActive = false;

// 입력
const keys = {};

// ======================= 공통: 시작 =======================
function startGameIfReady() {
  startBgmOnce(); // ✅ 첫 입력 시 BGM 시작 (게임 상태와 무관)

  if (gameState === "ready") {
    track("game_start"); // ✅ 플레이 시작 카운트

    gameState = "running";
    if (speechLoaded) {
      speechActive = true;
      speechVisible = true;
      speechBlinkCount = 0;
      speechTimer = 0;
    }
  }
}

// ======================= 입력(키보드) =======================
window.addEventListener("keydown", e => {
  keys[e.code] = true;
  if (e.code === "ArrowUp" || e.code === "ArrowDown") startGameIfReady();

  if (gameState === "finished" && e.code === "KeyQ") {
    track("game_restart", { method: "key_q" }); // ✅ Q키 재시작 카운트
    resetGame();
  }
});
window.addEventListener("keyup", e => { keys[e.code] = false; });

// ======================= END 클릭: 버튼만 동작 =======================
canvas.addEventListener("click", async (e) => {
  if (gameState !== "finished") return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  const btns = draw.endButtonRects;
  if (!btns) return;

  if (pointInRect(mx, my, btns.bu1)) { window.open(BU1_URL, "_blank"); return; }
  if (pointInRect(mx, my, btns.bu2)) { saveCanvasAsImage(); return; }
  if (pointInRect(mx, my, btns.bu3)) {
    try {
      const ok = await copyTextToClipboard(BU3_TEXT_TO_COPY);
      showToast(ok ? "복사됨!" : "복사 실패");
    } catch (_) {
      showToast("복사 실패");
    }
    return;
  }
if (pointInRect(mx, my, btns.bu4)) {
  // ✅ GA4: 유튜브 클릭 이벤트 기록
  if (typeof window.gtag === "function") {
    gtag("event", "youtube_click", {
      link_url: YOUTUBE_URL,
      where: "end_screen",
      button: "bu4"
    });
  }

  window.open(YOUTUBE_URL, "_blank");
  return;
}

  // ✅ sp2는 클릭 동작 없음 (요구사항)
});

// ======================= 리셋 =======================
function resetGame() {
  distance = 0;
  elapsedTime = 0;
  obstacles = [];
  specials = [];
  obstacleSpawnTimer = 0;

  nextZiSpawnTime = ZI_SPAWN_INTERVAL_SECONDS;
  nextCiSpawnTime = CI_SPAWN_INTERVAL_SECONDS;

  player.y = 200;
  gameState = "ready";

  playerFrameIndex = 0; playerFrameTimer = 0;
  objFrameIndex = 0; objFrameTimer = 0;
  ziFrameIndex = 0; ziFrameTimer = 0;

  speechTimer = 0;
  speechVisible = false;
  speechBlinkCount = 0;
  speechActive = false;

  keys["ArrowUp"] = false;
  keys["ArrowDown"] = false;

  toastText = "";
  toastTimer = 0;
}

// ======================= 깊이 스케일 계산(공통) =======================
function depthScaleFromY(y) {
  let t = (y - depthMinY) / (depthMaxY - depthMinY);
  t = clamp(t, 0, 1);
  return DEPTH_MIN_SCALE + t * (DEPTH_MAX_SCALE - DEPTH_MIN_SCALE);
}

// ======================= Y 범위 클램프(골 구간) =======================
function clampObjectYForX(obj) {
  let minY = depthMinY;
  let maxY = depthMaxY - obj.h;

  if (bgLoaded && bgImage.width) {
    const imgW = bgImage.width;
    const maxScroll = Math.max(imgW - canvas.width, 0);
    const progress = goalDistance > 0 ? clamp(distance / goalDistance, 0, 1) : 0;
    const scrollX = maxScroll * progress;

    const centerX = obj.x + obj.w / 2;
    const bgX = scrollX + centerX;

    const goalZoneWidth  = 600;
    const goalZoneStartX = imgW - goalZoneWidth;

    if (bgX >= goalZoneStartX) {
      const bandTop    = canvas.height - 140 - obj.h;
      const bandBottom = depthMaxY - obj.h;
      minY = bandTop;
      maxY = bandBottom;
    }
  }

  obj.y = clamp(obj.y, minY, maxY);
}

// ======================= 스폰 =======================
function spawnObstacle() {
  const size = 26;
  const spawnX = canvas.width + Math.random() * 120;
  const wiggleMax = 6;

  const baseTop = depthMinY + wiggleMax;
  const baseBottom = depthMaxY - size * 1.3 - wiggleMax * 2;
  let laneY = randRange(baseTop, baseBottom);

  const o = {
    x: spawnX, y: laneY, laneY,
    w: size, h: size * 1.3,
    speedFactor: randRange(OBSTACLE_MOVE_CONFIG.speedFactorMin, OBSTACLE_MOVE_CONFIG.speedFactorMax),
    wiggleAmp: randRange(OBSTACLE_MOVE_CONFIG.wiggleAmpMin, OBSTACLE_MOVE_CONFIG.wiggleAmpMax),
    wiggleFreq: randRange(OBSTACLE_MOVE_CONFIG.wiggleFreqMin, OBSTACLE_MOVE_CONFIG.wiggleFreqMax),
    wigglePhase: Math.random() * Math.PI * 2,
    wanderTimer: randRange(OBSTACLE_MOVE_CONFIG.wanderMin, OBSTACLE_MOVE_CONFIG.wanderMax),
    colliding: false,
    spriteType: ["PO","BE","CO","FG","FN","JI"][Math.floor(Math.random() * 6)],
    isCI: false
  };

  clampObjectYForX(o);
  o.laneY = o.y;
  obstacles.push(o);
}

function spawnSpecial() {
  const size = 40;
  const spawnX = canvas.width + 50 + Math.random() * 150;
  const wiggleMax = 4;

  const baseTop = depthMinY + wiggleMax;
  const baseBottom = depthMaxY - size * 2 - wiggleMax * 2;
  let laneY = randRange(baseTop, baseBottom);

  const s = {
    x: spawnX, y: laneY, laneY,
    w: size, h: size * 2,
    speedFactor: randRange(ZI_MOVE_CONFIG.speedFactorMin, ZI_MOVE_CONFIG.speedFactorMax),
    wiggleAmp: randRange(ZI_MOVE_CONFIG.wiggleAmpMin, ZI_MOVE_CONFIG.wiggleAmpMax),
    wiggleFreq: randRange(ZI_MOVE_CONFIG.wiggleFreqMin, ZI_MOVE_CONFIG.wiggleFreqMax),
    wigglePhase: Math.random() * Math.PI * 2,
    wanderTimer: randRange(ZI_MOVE_CONFIG.wanderMin, ZI_MOVE_CONFIG.wanderMax),
    colliding: false
  };

  clampObjectYForX(s);
  s.laneY = s.y;
  specials.push(s);
}

function spawnCiRusher() {
  const size = 26;
  const spawnX = canvas.width + 50;
  const wiggleMax = 3;

  const baseTop = depthMinY + wiggleMax;
  const baseBottom = depthMaxY - size * 1.3 - wiggleMax * 2;
  let laneY = randRange(baseTop, baseBottom);

  const o = {
    x: spawnX, y: laneY, laneY,
    w: size, h: size * 1.3,
    speedFactor: randRange(CI_MOVE_CONFIG.speedFactorMin, CI_MOVE_CONFIG.speedFactorMax),
    wiggleAmp: randRange(CI_MOVE_CONFIG.wiggleAmpMin, CI_MOVE_CONFIG.wiggleAmpMax),
    wiggleFreq: randRange(CI_MOVE_CONFIG.wiggleFreqMin, CI_MOVE_CONFIG.wiggleFreqMax),
    wigglePhase: Math.random() * Math.PI * 2,
    wanderTimer: randRange(CI_MOVE_CONFIG.wanderMin, CI_MOVE_CONFIG.wanderMax),
    colliding: false,
    spriteType: "CI",
    isCI: true
  };

  clampObjectYForX(o);
  o.laneY = o.y;
  obstacles.push(o);
}

// ======================= 말풍선 =======================
function updateSpeech(dt) {
  if (!speechActive || !speechLoaded || gameState !== "running") return;
  if (speechBlinkCount >= SPEECH_MAX_BLINKS) return;

  speechTimer += dt;

  if (speechVisible) {
    if (speechTimer >= SPEECH_ON_TIME) {
      speechTimer = 0;
      speechVisible = false;
      speechBlinkCount++;
      if (speechBlinkCount >= SPEECH_MAX_BLINKS) {
        speechActive = false;
        speechVisible = false;
      }
    }
  } else {
    if (speechTimer >= SPEECH_OFF_TIME) {
      speechTimer = 0;
      speechVisible = true;
    }
  }
}

// ======================= 애니메이션 =======================
function updatePlayerAnimation(dt, slowScale, hasCiCollision) {
  if (playerFramesLoaded < 1) return;
  if (hasCiCollision) return;

  const animSpeed = PLAYER_BASE_FPS * (0.7 + 0.3 * slowScale);
  const frameDuration = 1 / animSpeed;

  playerFrameTimer += dt;
  while (playerFrameTimer >= frameDuration) {
    playerFrameTimer -= frameDuration;
    playerFrameIndex = (playerFrameIndex + 1) % PLAYER_FRAME_COUNT;
  }
}
function updateObjectAnimation(dt) {
  const frameDurationObj = 1 / OBJ_BASE_FPS;
  objFrameTimer += dt;
  while (objFrameTimer >= frameDurationObj) {
    objFrameTimer -= frameDurationObj;
    objFrameIndex = (objFrameIndex + 1) % OBJ_FRAME_COUNT;
  }

  const frameDurationZi = 1 / ZI_BASE_FPS;
  ziFrameTimer += dt;
  while (ziFrameTimer >= frameDurationZi) {
    ziFrameTimer -= frameDurationZi;
    ziFrameIndex = (ziFrameIndex + 1) % ZI_FRAME_COUNT;
  }
}

// ======================= 충돌 =======================
function computeClosenessFromPlayer(player, obj) {
  const pCenterX = player.x + player.w / 2;
  const pCenterY = player.y + player.h / 2;

  const expandedHalfW = (player.w * 1.5 * PLAYER_HITBOX_SCALE) / 2;
  const expandedHalfH = (player.h * 1.5 * PLAYER_HITBOX_SCALE) / 2;

  const oCenterX = obj.x + obj.w / 2;
  const oCenterY = obj.y + obj.h / 2;

  const oHalfW = (obj.w * OBJECT_HITBOX_SCALE) / 2;

  // ✅ (난이도 조정) 오브젝트 판정 Y축 절반 축소
  const oHalfH = (obj.h * OBJECT_HITBOX_SCALE * OBJECT_HITBOX_Y_FACTOR) / 2;

  const dx = pCenterX - oCenterX;
  const dy = pCenterY - oCenterY;

  const overlapX = expandedHalfW + oHalfW - Math.abs(dx);
  const overlapY = expandedHalfH + oHalfH - Math.abs(dy);

  if (overlapX <= 0 || overlapY <= 0) return { colliding: false, closeness: 0 };

  const normX = overlapX / (expandedHalfW + oHalfW);
  const normY = overlapY / (expandedHalfH + oHalfH);
  return { colliding: true, closeness: (normX + normY) / 2 };
}

function handleCollisionList(list, options, accum) {
  const { player } = options;
  const weightFn = options.weightFn || (() => 1);
  const onCollide = options.onCollide || (() => {});

  for (const obj of list) {
    const { colliding, closeness } = computeClosenessFromPlayer(player, obj);
    if (colliding) {
      obj.colliding = true;
      const weight = weightFn(obj);
      accum.totalClosenessWeighted += closeness * weight;
      accum.effectiveCount += weight;
      onCollide(obj);
    } else {
      obj.colliding = false;
    }
  }
}

// ======================= 이동 =======================
function randomizeWalkerParams(entity, config) {
  entity.speedFactor = randRange(config.speedFactorMin, config.speedFactorMax);
  entity.wiggleAmp   = randRange(config.wiggleAmpMin, config.wiggleAmpMax);
  entity.wiggleFreq  = randRange(config.wiggleFreqMin, config.wiggleFreqMax);
  entity.wanderTimer = randRange(config.wanderMin, config.wanderMax);
}

function updateWalker(entity, dt, moveConfig) {
  // ✅ (난이도 조정) 충돌 시 오브젝트 감속 "절반만" 적용
  const collisionSlow = entity.colliding ? 0.5 : 1.0;

  const xSpeed = baseSpeed * entity.speedFactor * collisionSlow;
  entity.x -= xSpeed * dt;

  entity.wanderTimer -= dt;
  if (entity.wanderTimer <= 0) randomizeWalkerParams(entity, moveConfig);

  entity.wigglePhase += entity.wiggleFreq * dt;
  const offset = Math.sin(entity.wigglePhase) * entity.wiggleAmp;
  entity.y = entity.laneY + offset;

  if (entity.y < depthMinY) entity.y = depthMinY;
  clampObjectYForX(entity);
}

// ======================= 업데이트 =======================
function update(dt) {
  updateSpeech(dt);
  if (gameState !== "running") return;

  elapsedTime += dt;

  let accum = { totalClosenessWeighted: 0, effectiveCount: 0 };
  let hasCiCollision = false;

  // 1) 오브젝트/CI 충돌 누적
  handleCollisionList(obstacles, {
    player,
    weightFn: () => 1,
    onCollide(obj) { if (obj.isCI) hasCiCollision = true; }
  }, accum);

  // 2) ZI 충돌 누적
  handleCollisionList(specials, {
    player,
    weightFn: () => 1.2
  }, accum);

  // ✅ (난이도 조정) 플레이어가 최상단/최하단에 "붙어있으면" 1개 충돌과 동일 감속을 추가
  const EDGE_EPS = 0.0001;
  const atTopEdge = player.y <= playerMinY + EDGE_EPS;
  const atBottomEdge = player.y >= playerMaxY - EDGE_EPS;

  if (atTopEdge || atBottomEdge) {
    accum.totalClosenessWeighted += 1 * 1;
    accum.effectiveCount += 1;
  }

  // 3) 감속 계산
  let slowScale = 1;

  if (hasCiCollision) {
    slowScale = 0;
  } else if (accum.effectiveCount > 0) {
    const avgCloseness = accum.totalClosenessWeighted / accum.effectiveCount;
    const countRough = Math.round(accum.effectiveCount);

    let tierMinSpeed, tierMaxSpeed;
    if (countRough <= 1) { tierMaxSpeed = 0.8; tierMinSpeed = 0.4; }
    else if (countRough === 2) { tierMaxSpeed = 0.5; tierMinSpeed = 0.1; }
    else { tierMaxSpeed = 0.3; tierMinSpeed = 0.1; }

    if (tierMinSpeed < MIN_SLOW_FACTOR) tierMinSpeed = MIN_SLOW_FACTOR;

    const t = clamp(avgCloseness, 0, 1);
    slowScale = tierMaxSpeed - t * (tierMaxSpeed - tierMinSpeed);
    if (slowScale < MIN_SLOW_FACTOR) slowScale = MIN_SLOW_FACTOR;
  }

  const isSlowed = slowScale < 1;

  // 4) 거리 & 플레이어 이동
  const distanceSpeed = baseSpeed * slowScale;
  const moveSpeedY = player.baseSpeedY * slowScale;

  distance += distanceSpeed * dt;
if (distance >= goalDistance) {
  distance = goalDistance;
  track("game_finish", { time_sec: Number(elapsedTime.toFixed(2)) }); // ✅ 클리어 시간도 같이
  gameState = "finished";
}

  if (keys["ArrowUp"]) player.y -= moveSpeedY * dt;
  if (keys["ArrowDown"]) player.y += moveSpeedY * dt;
  player.y = clamp(player.y, playerMinY, playerMaxY);

  // 5) 스폰
  obstacleSpawnTimer -= dt;
  if (obstacleSpawnTimer <= 0) {
    spawnObstacle();
    obstacleSpawnTimer = randRange(OBSTACLE_SPAWN_INTERVAL_MIN, OBSTACLE_SPAWN_INTERVAL_MAX);
  }

  if (elapsedTime >= nextZiSpawnTime) {
    spawnSpecial();
    nextZiSpawnTime += ZI_SPAWN_INTERVAL_SECONDS;
  }

  if (elapsedTime >= nextCiSpawnTime) {
    spawnCiRusher();
    nextCiSpawnTime += CI_SPAWN_INTERVAL_SECONDS;
  }

  // 6) 이동
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    updateWalker(o, dt, o.isCI ? CI_MOVE_CONFIG : OBSTACLE_MOVE_CONFIG);
    if (o.x + o.w < 0) obstacles.splice(i, 1);
  }

  for (let i = specials.length - 1; i >= 0; i--) {
    const s = specials[i];
    updateWalker(s, dt, ZI_MOVE_CONFIG);
    if (s.x + s.w < 0) specials.splice(i, 1);
  }

  // 7) 애니메이션
  updatePlayerAnimation(dt, slowScale, hasCiCollision);
  updateObjectAnimation(dt);

  update.isSlowedThisFrame = isSlowed;
  update.slowScaleThisFrame = slowScale;
  update.hasCiCollisionThisFrame = hasCiCollision;
}

// ======================= 그리기 =======================
function drawBackground() {
  if (!bgLoaded) {
    ctx.fillStyle = "#3b4f99";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return;
  }

  const imgW = bgImage.width;
  const imgH = bgImage.height;

  const maxScroll = Math.max(imgW - canvas.width, 0);
  const progress = goalDistance > 0 ? clamp(distance / goalDistance, 0, 1) : 0;
  const scrollX = maxScroll * progress;

  ctx.drawImage(bgImage, -scrollX, 0, imgW, imgH);
}

function drawPlayerSprite(drawX, drawY, drawW, drawH, isSlowed) {
  if (playerFramesLoaded < 1) {
    ctx.fillStyle = isSlowed ? "#ff8080" : player.color;
    ctx.fillRect(drawX, drawY, drawW, drawH);
    return;
  }
  const img = playerFrames[playerFrameIndex % PLAYER_FRAME_COUNT];
  ctx.drawImage(img, 0, 0, PLAYER_FRAME_WIDTH, PLAYER_FRAME_HEIGHT, drawX, drawY, drawW, drawH);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 시작 화면
  if (gameState === "ready") {
    if (mainLoaded) ctx.drawImage(mainImage, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height); }
    drawToast();
    return;
  }

  drawBackground();

  // 진행도 바
  const progress = distance / goalDistance;
  ctx.fillStyle = "#960001";
  ctx.fillRect(50, 20, 700, 10);

  ctx.fillStyle = "#ffb100";
  ctx.fillRect(50, 20, 700 * clamp(progress, 0, 1), 10);

  ctx.strokeStyle = "#aaa";
  ctx.strokeRect(50, 20, 700, 10);

  const isSlowed = !!update.isSlowedThisFrame;
  const slowScale = update.slowScaleThisFrame ?? 1;

  // 상단 텍스트
  ctx.fillStyle = "#960001";
  ctx.font = "16px 'Pretendard'";
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  ctx.fillText(`롯데리아 사전예약까지 : ${elapsedTime.toFixed(2)}초`, 50, 50);

  // 감속 문구
  if (isSlowed && gameState === "running") {
    const slowPercent = Math.round(slowScale * 100);
    ctx.fillStyle = "#960001";
    ctx.font = "16px 'Pretendard'";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(`밀려서 사전예약에 늦는 중 (${slowPercent}%)`, canvas.width / 2, canvas.height - 20);
  }

  // 레이어 리스트
  const renderList = [];

  // 오브젝트
  for (const o of obstacles) {
    const scale = depthScaleFromY(o.y);
    const drawW = OBJ_FRAME_WIDTH * scale;
    const drawH = OBJ_FRAME_HEIGHT * scale;

    const centerX = o.x + o.w / 2;
    const centerY = o.y + o.h / 2;
    const groundY = centerY + drawH * 0.35;

    renderList.push({ type:"obj", ref:o, scale, drawW, drawH, centerX, centerY, groundY });
  }

  // ZI
  for (const s of specials) {
    const scale = depthScaleFromY(s.y);
    const drawW = ZI_FRAME_WIDTH * scale;
    const drawH = ZI_FRAME_HEIGHT * scale;

    const centerX = s.x + s.w / 2;
    const centerY = s.y + s.h / 2;
    const groundY = centerY + drawH * 0.35;

    renderList.push({ type:"zi", ref:s, scale, drawW, drawH, centerX, centerY, groundY });
  }

  // ✅ 플레이어도 2.5D 스케일 적용
  const playerScale = depthScaleFromY(player.y);
  const pDrawW = PLAYER_FRAME_WIDTH * playerScale;
  const pDrawH = PLAYER_FRAME_HEIGHT * playerScale;

  const pCenterX = player.x + player.w / 2;

  const baseFeetOffset = 15;
  const feetOffsetScaled = baseFeetOffset * playerScale;
  const pFeetY = (player.y + player.h) - feetOffsetScaled;

  const pDrawX = pCenterX - pDrawW / 2;
  const pDrawY = pFeetY - (pDrawH - feetOffsetScaled);

  renderList.push({
    type: "player",
    scale: playerScale,
    drawX: pDrawX,
    drawY: pDrawY,
    drawW: pDrawW,
    drawH: pDrawH,
    centerX: pCenterX,
    feetY: pFeetY,
    groundY: pFeetY
  });

  // 깊이 순 정렬
  renderList.sort((a, b) => a.groundY - b.groundY);

  // 렌더
  for (const item of renderList) {
    if (item.type === "obj") {
      const o = item.ref;
      const { drawW, drawH, centerX, centerY } = item;

      const ciOffsetY = o.isCI ? 10 : 0;

      ctx.fillStyle = SHADOW_RGBA;
      ctx.beginPath();
      ctx.ellipse(centerX, centerY + drawH * 0.35 + ciOffsetY, drawW * 0.25, drawH * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      const spriteType = o.spriteType || "PO";
      const spriteSet = objSpriteSets[spriteType];

      if (spriteSet && spriteSet.loaded > 0) {
        const img = spriteSet.frames[objFrameIndex % spriteSet.frames.length];
        const dx = centerX - drawW / 2;
        const dy = centerY - drawH / 2;
        ctx.drawImage(img, 0, 0, OBJ_FRAME_WIDTH, OBJ_FRAME_HEIGHT, dx, dy, drawW, drawH);
      } else {
        ctx.fillStyle = o.colliding ? (o.isCI ? "#ff0000" : "#ffb366") : "#8b4513";
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, drawW / 2, drawH / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

    } else if (item.type === "zi") {
      const { drawW, drawH, centerX, centerY } = item;

      ctx.fillStyle = SHADOW_RGBA_STRONG;
      ctx.beginPath();
      ctx.ellipse(centerX, centerY + drawH * 0.35, drawW * 0.25, drawH * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      if (ziFramesLoaded > 0) {
        const img = ziFrames[ziFrameIndex % ZI_FRAME_COUNT];
        const dx = centerX - drawW / 2;
        const dy = centerY - drawH / 2;
        ctx.drawImage(img, 0, 0, ZI_FRAME_WIDTH, ZI_FRAME_HEIGHT, dx, dy, drawW, drawH);
      } else {
        ctx.fillStyle = "#aa0000";
        ctx.fillRect(centerX - drawW / 2, centerY - drawH / 2, drawW, drawH);
      }

    } else if (item.type === "player") {
      const { drawX, drawY, drawW, drawH, centerX, feetY, scale } = item;

      ctx.fillStyle = SHADOW_RGBA;
      ctx.beginPath();
      ctx.ellipse(centerX, feetY, drawW * 0.25, drawH * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      drawPlayerSprite(drawX, drawY, drawW, drawH, isSlowed);

      if (gameState === "running" && speechActive && speechVisible && speechLoaded) {
        const bx = drawX - 50 * scale;
        const by = drawY - 30 * scale;
        ctx.drawImage(speechImg, bx, by, 80 * scale, 50 * scale);
      }
    }
  }

  // END 화면
  if (gameState === "finished") {
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (endLoaded) ctx.drawImage(endImage, 0, 0, canvas.width, canvas.height);

    const leftPad = 600;
    const topPad  = 150;

    const bu1X = leftPad, bu1Y = topPad;
    const bu2X = leftPad, bu2Y = topPad + 42 + 15;
    const bu3X = bu2X + 42 + 12, bu3Y = bu2Y;
    const bu4X = bu3X + 42 + 12, bu4Y = bu2Y;

    // ✅ sp2: 원하는 좌표 (639, 257), w100 h60
    const sp2X = 637, sp2Y = 257;

    draw.endButtonRects = {
      bu1: { x: bu1X, y: bu1Y, w: 150, h: 42 },
      bu2: { x: bu2X, y: bu2Y, w: 42,  h: 42 },
      bu3: { x: bu3X, y: bu3Y, w: 42,  h: 42 },
      bu4: { x: bu4X, y: bu4Y, w: 42,  h: 42 },
      sp2: { x: sp2X, y: sp2Y, w: 100, h: 60 }
    };

    if (!suppressEndButtonsForCapture) {
      const map = draw.endButtonRects;
      for (const b of endButtons) {
        const r = map[b.key];
        if (r && b.loaded) ctx.drawImage(b.img, r.x, r.y, r.w, r.h);
      }
    }

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";
    ctx.font = "28px 'Pretendard'";
    ctx.fillText(`${elapsedTime.toFixed(2)}초`, canvas.width / 2, 305);
  } else {
    draw.endButtonRects = null;
  }

  drawToast();
}

// ======================= 게임 루프 =======================
function gameLoop(t) {
  if (!lastTime) lastTime = t;
  const dt = (t - lastTime) / 1000;
  lastTime = t;

  updateToast(dt);
  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

// ======================= 하단 버튼(모바일/PC) =======================
const btnUp = document.getElementById("btn-up");
const btnDown = document.getElementById("btn-down");
const btnRestart = document.getElementById("btn-restart");

function bindHoldButton(button, keyCode) {
  if (!button) return;

  const onPress = (e) => {
    e.preventDefault();
    keys[keyCode] = true;
    if (keyCode === "ArrowUp" || keyCode === "ArrowDown") startGameIfReady();
  };

  const onRelease = (e) => {
    e.preventDefault();
    keys[keyCode] = false;
  };

  button.addEventListener("mousedown", onPress);
  button.addEventListener("touchstart", onPress, { passive: false });

  button.addEventListener("mouseup", onRelease);
  button.addEventListener("mouseleave", onRelease);
  button.addEventListener("touchend", onRelease, { passive: false });
  button.addEventListener("touchcancel", onRelease, { passive: false });
}

bindHoldButton(btnUp, "ArrowUp");
bindHoldButton(btnDown, "ArrowDown");

if (btnRestart) {
  const doRestart = (e) => {
    e.preventDefault();
    track("game_restart", { method: "button" }); // ✅ 버튼 재시작 카운트
    resetGame();
  };
  btnRestart.addEventListener("click", doRestart);
  btnRestart.addEventListener("touchend", doRestart, { passive: false });
}
</script>
</body>
</html>
